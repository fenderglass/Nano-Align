#!/usr/bin/env python2.7

#(c) 2015-2016 by Authors
#This file is a part of Nano-Align program.
#Released under the BSD license (see LICENSE file)

"""
Compares experimental and theoretical signals,
generated by different models
"""

from __future__ import print_function
import sys
import os
import argparse

from statsmodels.nonparametric.smoothers_lowess import lowess
from scipy.interpolate import interp1d
from scipy.spatial import distance
import matplotlib.pyplot as plt
import matplotlib
import numpy as np

nanoalign_root = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
sys.path.insert(0, nanoalign_root)
import nanoalign.signal_proc as sp
from nanoalign.svr_blockade import SvrBlockade
from nanoalign.mv_blockade import MvBlockade
from nanoalign.blockade import read_mat


import pyximport; pyximport.install()
from nanoalign.timewrap import edr_distance


def plot_blockades(blockades_file, svr_file, cluster_size, show_text):
    """
    Pretty plotting
    """
    WINDOW = 4

    blockades = read_mat(blockades_file)
    clusters = sp.preprocess_blockades(blockades, cluster_size=cluster_size,
                                       min_dwell=0.5, max_dwell=20)
    peptide = clusters[0].blockades[0].peptide

    svr_model = SvrBlockade()
    svr_model.load_from_pickle(svr_file)
    svr_signal = svr_model.peptide_signal(peptide)
    mv_signal = MvBlockade().peptide_signal(peptide)

    for cluster in clusters:
        cluster.consensus = sp.resample(cluster.consensus, 1000)

        signal_length = len(cluster.consensus)
        mv_interp = sp.resample(mv_signal, len(cluster.consensus))
        svr_interp = sp.resample(svr_signal, len(cluster.consensus))
        smooth_cons = lowess(cluster.consensus, range(len(cluster.consensus)),
                             return_sorted=False, frac=2.0 / len(peptide))

        svr_corr = edr_distance(cluster.consensus, svr_interp)
        mv_corr = edr_distance(smooth_cons, svr_interp)
        print("SVR correlation: {0:5.2f}\tMV correlation: {1:5.2f}"
                .format(svr_corr, mv_corr), file=sys.stderr)

        #################
        ##pretty plotting
        x_axis = np.linspace(0, len(peptide) + 1, signal_length)
        matplotlib.rcParams.update({"font.size": 16})
        fig = plt.subplot()
        fig.plot(x_axis, cluster.consensus, label="Empirical signal", linewidth=1.5)
        #fig.plot(x_axis, smooth_cons, label="Smooth signal", linewidth=1.5)
        #fig.plot(x_axis, mv_interp, label="MV model", linewidth=1.5)
        fig.plot(x_axis, svr_interp, label="SVR model", linewidth=1.5)
        #fig.plot(x_axis, svr_interp[::-1], label="Rev SVR model", linewidth=1.5)

        fig.spines["right"].set_visible(False)
        fig.spines["top"].set_visible(False)
        fig.get_xaxis().tick_bottom()
        fig.get_yaxis().tick_left()
        fig.set_xlim(0, len(peptide) + 1)
        fig.set_xlabel("Putative AA position")
        fig.set_ylabel("Normalized signal")

        legend = fig.legend(loc="lower left", frameon=False)
        for label in legend.get_lines():
            label.set_linewidth(2)
        for label in legend.get_texts():
            label.set_fontsize(16)

        if show_text:
            #adding AAs text:
            event_mean = np.mean(cluster.consensus)
            acids_pos = _get_aa_positions(peptide, WINDOW, x_axis[-1])
            for i, aa in enumerate(peptide):
                fig.text(acids_pos[i], event_mean - 2, aa, fontsize=16)

        plt.show()
        ################


def _get_aa_positions(peptide, window_size, plot_len):
    """
    Return AA position on the plot
    """
    num_peaks = len(peptide) + window_size - 1
    peak_shift = float(plot_len) / (num_peaks - 1)
    initial_shift = (window_size - 1) * peak_shift / 2
    positions = []
    for aa in xrange(len(peptide)):
        positions.append(initial_shift + aa * peak_shift)
    return positions


def main():
    parser = argparse.ArgumentParser(description="Plotting blockade signals "
                                "against theoreticla models", formatter_class= \
                                argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("blockades_file", metavar="blockades_file",
                        help="path to blockades file (in mat format)")
    parser.add_argument("svr_file", metavar="svr_file",
                        help="path to SVR file (in Python's pickle format)")
    parser.add_argument("-c", "--cluster-size", dest="cluster_size", type=int,
                        default=10, help="blockades cluster size")
    parser.add_argument("-t", "--aa-text", action="store_true",
                        default=False, dest="aa_text",
                        help="show AAs")
    args = parser.parse_args()

    plot_blockades(args.blockades_file, args.svr_file,
                   args.cluster_size, args.aa_text)
    #self_compare(clusters, SMOOTH)
    return 0


if __name__ == "__main__":
    sys.exit(main())
