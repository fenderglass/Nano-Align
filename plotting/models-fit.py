#!/usr/bin/env python2.7

#(c) 2015-2016 by Authors
#This file is a part of Nano-Align program.
#Released under the BSD license (see LICENSE file)

"""
Compares experimental and theoretical signals,
generated by different models
"""

from __future__ import print_function
import sys
import os
import argparse

from scipy.interpolate import interp1d
from scipy.spatial import distance
import matplotlib.pyplot as plt
import matplotlib
import numpy as np

nanoalign_root = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
sys.path.insert(0, nanoalign_root)

import nanoalign.signal_proc as sp
from nanoalign.mean_volume import MvBlockade
from nanoalign.blockade import read_mat
from nanoalign.model_loader import load_model


def plot_blockades(blockades_file, model_files,
                   cluster_size, show_text):
    """
    Pretty plotting
    """
    WINDOW = 4

    blockades = read_mat(blockades_file)
    clusters = sp.preprocess_blockades(blockades, cluster_size=cluster_size,
                                       min_dwell=0.5, max_dwell=20)
    peptide = clusters[0].blockades[0].peptide

    models = []
    for model_file in model_files:
        models.append(load_model(model_file))
    #svr_signal = model.peptide_signal(peptide)
    #mv_signal = MvBlockade().peptide_signal(peptide)

    for cluster in clusters:
        #cluster.consensus = sp.discretize(cluster.consensus, len(peptide))
        signal_length = len(cluster.consensus)

        x_axis = np.linspace(0, len(peptide) + 1, signal_length)
        matplotlib.rcParams.update({"font.size": 16})
        fig = plt.subplot()

        fig.spines["right"].set_visible(False)
        fig.spines["top"].set_visible(False)
        fig.get_xaxis().tick_bottom()
        fig.get_yaxis().tick_left()
        fig.set_xlim(0, len(peptide) + 1)
        fig.set_xlabel("Putative AA position")
        fig.set_ylabel("Normalized signal")

        fig.plot(x_axis, cluster.consensus, label="Empirical signal", linewidth=1.5)

        ################
        for model in models:
            model_signal = model.peptide_signal(peptide)
            model_grid = [i * signal_length / (len(model_signal) - 1)
                          for i in xrange(len(model_signal))]

            interp_fun = interp1d(model_grid, model_signal, kind="linear")
            model_interp = interp_fun(xrange(signal_length))

            corr = 1 - distance.correlation(cluster.consensus, model_interp)
            print("{0} correlation: {1:5.2f}\t".format(model.name, corr),
                  file=sys.stderr)
            fig.plot(x_axis, model_interp, label=model.name, linewidth=2)
        ##############

        legend = fig.legend(loc="lower left", frameon=False)
        for label in legend.get_lines():
            label.set_linewidth(2)
        for label in legend.get_texts():
            label.set_fontsize(16)

        if show_text:
            #adding AAs text:
            event_mean = np.mean(cluster.consensus)
            acids_pos = _get_aa_positions(peptide, WINDOW, x_axis[-1])
            for i, aa in enumerate(peptide):
                fig.text(acids_pos[i], event_mean - 2, aa, fontsize=16)

        plt.show()


def _get_aa_positions(peptide, window_size, plot_len):
    """
    Return AA position on the plot
    """
    num_peaks = len(peptide) + window_size - 1
    peak_shift = float(plot_len) / (num_peaks - 1)
    initial_shift = (window_size - 1) * peak_shift / 2
    positions = []
    for aa in xrange(len(peptide)):
        positions.append(initial_shift + aa * peak_shift)
    return positions


def main():
    parser = argparse.ArgumentParser(description="Plotting nanospectra "
                                "against the regression models", formatter_class= \
                                argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("nanospectra_file", metavar="nanospectra_file",
                        help="path to blockades file (in mat format)")
    parser.add_argument("model_files", metavar="model_files",
                        help="comma-sparated paths to files with trained models "
                             "('-' for mean volume)")
    parser.add_argument("-c", "--cluster-size", dest="cluster_size", type=int,
                        default=10, help="blockades cluster size")
    parser.add_argument("-t", "--aa-text", action="store_true",
                        default=False, dest="aa_text",
                        help="show AAs")
    args = parser.parse_args()

    plot_blockades(args.nanospectra_file, args.model_files.split(","),
                   args.cluster_size, args.aa_text)
    return 0


if __name__ == "__main__":
    sys.exit(main())
